library(readr)
library(dplyr)
library(stringr)
library(reshape2)

# Path where we will store out final result.
resultPath <- 'averages.txt'

printf <- function(...) {
    invisible(print(sprintf(...)))
}

# The current working directory needs to be the 'UCI HAR Dataset'
# directory containing the extracted files.

stopifnot(file.exists('features.txt'))
stopifnot(file.exists('activity_labels.txt'))

# The input is a dataset measurement name in one of the following forms:
#     tName-func()-X
#     tName-func()
#
# Produce a descriptive name based on information in the codebook.
# The final descriptive name contains up to 4 components.
#
#     - The signal name
#     - The (optional) axial direction
#     - The signal processing that was applied,  Euclidian Norm or Fast Fourier Transform
#     - The statistical function that was applied, Mean or StdDev (Standard Deviation).
#
# Names not matching the measurement forms are return unharmed.
#
# Examples:
#     fBodyAccJerk-std()-Z    BodyAccJerkZFourierTransformStdDev
#     fBodyAccMag-mean()      BodyAccMagFourierTransformMean
makeMeasurementName <- function(name) {
    mapSignal <- function(namePart) {
       leading <- str_sub(namePart, 1, 1)
       remainder <- str_sub(namePart, 2)

       if (leading == 't') {
           c(remainder, 'EuclidianNorm')
       } else {
           stopifnot(leading == 'f')
           c(remainder, 'FourierTransform')
       }
    }

    mapFunction <- function(funcName) {
        if (funcName == 'std()') {
            'StdDev'
        } else {
            stopifnot(funcName == 'mean()')
            'Mean'
        }
    }

    components <- unlist(str_split(name, '-'))

    if (length(components) == 3) {
        # Matches fBodyAccJerk-std()-Z.
        s <- mapSignal(components[1])
        str_c(s[1], components[3], s[2], mapFunction(components[2]))
    } else if (length(components) == 2) {
        # fBodyBodyGyroMag-std()
        s <- mapSignal(components[1])
        str_c(s[1], s[2], mapFunction(components[2]))
    } else {
        # Matches
        stopifnot(length(components) == 1)
        name
    }
}
# Read features.txt to get the names for the data columns. We use
# read.table rather than read_table because read.table separates by
# arbitrary whitespace and read_table assumes fixed-width columns.
readFeatures <- function() {
    featuresTable <- read.table(
        'features.txt', header = FALSE,
        col.names = c('FeatureId', 'FeatureName'),
        colClasses = c('integer', 'character'))

    # Return a vector of feature names.
    featuresTable$FeatureName
}

# Read activity_labels.txt to get the activity names.
readActivities <- function() {
    activityTable <- read.table(
        'activity_labels.txt', header = FALSE,
        col.names = c('ActivityId', 'ActivityName'),
        colClasses = c('integer', 'character'))

    activityTable
}

# Given a character vector of 'V1' ... 'Vxxx', extract the numeric
# portion and use that to subset the featureNames character vector.
convertColumnNames <- function(colNames, featureNames) {
    # Extract the numeric portion of the column name.
    colIndices <- gsub('V([0-9]+)', '\\1', colNames)
    # Convert to numeric.
    colIndices <- as.numeric(colIndices)
    # Subset the feature names with the indices from the column names.
    featureNames[colIndices]
}

# Given directory = 'foo' and base = 'bar', return 'foo/base_foo.txt'.
makeDatasetPath <- function(directory, base) {
    paste(directory, paste(base, '_', directory, '.txt', sep = ''), sep = '/')
}

# Read the measurement values for a dataset. We extract only the mean
# and standard deviation measurements, and rename the columns using
# their canonical feature names.
readMeasurements <- function(path, featureNames) {

    # Read the data values. Don't bother naming the columns yet since
    # they have duplicate names that will get us into trouble. Below
    # we will depend on the column names generated by read.table().
    dataValues <- read.table(path, header = FALSE)

    # The features contain measurements named -mean() and meanFreq().
    # From the code book, meanFreq() is "Weighted average of the
    # frequency components to obtain a mean frequency" and mean() is
    # "mean value". We are asked for the mean of a measurement, which
    # strongly implies the latter, so we only take feature names with
    # 'mean()'
    meanCols <- grep('mean\\(\\)', featureNames)
    stdCols <- grep('std\\(\\)', featureNames)

    # Collect just the columns with matching 'mean' or 'std' feature
    # names, so at this point we have just those measurements.
    dataValues <- bind_cols(dataValues[,meanCols], dataValues[,stdCols])

    # The columns of the measurements dataset are called V1 ... Vnnn. Extract
    # the numeric portion so that we can index back into the feature names.
    # Fortunately, at this point there are no duplicate feature names.
    names(dataValues) <- convertColumnNames(names(dataValues), featureNames)

    # Return the values.
    tbl_df(dataValues)
}

# Read a UCI dataset from the given directory.
readDataset <- function(directory, featureNames) {
    # Path to the sample values.
    measurementPath <- makeDatasetPath(directory, 'X')
    # Path to the activities for each sample.
    activityPath <- makeDatasetPath(directory, 'y')
    # Path to the subject for each sample.
    subjectPath <- makeDatasetPath(directory, 'subject')

    measurementValues <- readMeasurements(
        measurementPath, featureNames)

    activityValues <- read.table(
        activityPath, header = FALSE, col.names = c('ActivityId'))

    subjectValues <- read.table(
        subjectPath, header = FALSE, col.names = c('SubjectId'), colClasses = c('integer'))

    # Bind the activities and the subject IDs into the table,
    # returning a dplyr data frame tbl.
    tbl_df(bind_cols(measurementValues, activityValues, subjectValues))
}

printf("reading dataset metadata")

# Read the activity metadata.
uci.meta.activity <- readActivities()
# Read the features metadata.
uci.meta.features <- readFeatures()

printf("reading 'test' dataset")
uci.dataset.test <- readDataset('test', uci.meta.features)

printf("reading 'train' dataset")
uci.dataset.train <- readDataset('train', uci.meta.features)

# Concat the test and training observations.
uci.dataset.combined <- bind_rows(uci.dataset.test, uci.dataset.train)

printf("rewriting activities with activity names")

# Replace the 'ActivityId' column with the 'Activity' using the names
# we loaded earlier from the activify labels.
uci.dataset.combined <-
    mutate(uci.dataset.combined, Activity = uci.meta.activity$ActivityName[ActivityId]) %>%
    select(-ActivityId)

# Finally, convert the activity into a factor, since we have a small
# number of well-defined values.
uci.dataset.combined$Activity <- as.factor(uci.dataset.combined$Activity)

printf("labelling with descriptive variable names")

# Rename the variables in the combined dataset by generating more
# descriptive names.
names(uci.dataset.combined) <- sapply(names(uci.dataset.combined), makeMeasurementName)

# Now we have completed steps 1-3 and we have the dataset in uci.dataset.combined.

printf("creating grouped averages")

# Create a second, independent tidy data set with the average of each variable for
# each activity and each subject.
uci.dataset.averaged <-
    melt(uci.dataset.combined, id.vars = c('SubjectId', 'Activity')) %>%
    group_by(SubjectId, Activity) %>%
    summarize(Mean = mean(value))

printf("writing results to %s", resultPath)

# Write the final table.
write.table(uci.dataset.averaged, resultPath, row.name=FALSE)
